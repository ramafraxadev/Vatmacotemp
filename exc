import { flushPromises, mount, shallowMount } from '@vue/test-utils'
import { afterEach, beforeEach, describe, expect, it, vi } from 'vitest'
import { createPinia, setActivePinia } from 'pinia'
import { createTestingPinia } from '@pinia/testing'

import axiosApi from 'axios'

import mckitui from 'mc-kit-ui/src/plugins/mc-kit-ui'
import axios from '@/plugins/axios'
import dayjs from '@/plugins/dayjs'
import store from '@/store/store'
import router from '~/tests/utils/test-router'

import { useFacturationDocumentsStore } from '@/stores/facturation/store-facturation-documents'
import { useFacturationModelesStore } from '@/stores/facturation/store-facturation-modeles'
import { useFacturationParametresStore } from '@/stores/facturation/store-facturation-parametres'
import { useFacturationClientsStore } from '@/stores/facturation/store-facturation-clients'
import { useFacturationAdherentsStore } from '@/stores/facturation/store-facturation-adherents'
import { useFacturationGenerationDocumentsStore } from '@/stores/facturation/store-facturation-generation-documents'
import { useFacturationNumerotationsStore } from '@/stores/facturation/store-facturation-numerotations'

import '~/config/templates/env-config'
import documents from '~/tests/__fixtures__/facturation/api-facturation-documents-succes.json'
import modeles from '~/tests/__fixtures__/facturation/api-facturation-modeles-succes.json'
import numerotations from '~/tests/__fixtures__/facturation/api-facturation-numerotations-succes.json'
import documentDetail from '~/tests/__fixtures__/facturation/api-facturation-documents-detail-succes.json'
import clientDetail from '~/tests/__fixtures__/facturation/api-facturation-clients-detail-succes.json'
import userDemo from '~/tests/__fixtures__/commun/api-compte-utilisateur-succes.json'
import parametres from '~/tests/__fixtures__/facturation/api-facturation-parametres-succes.json'

import FacturationDocuments from '../FacturationDocuments.vue'
import { useCompteUtilisateurStore } from '../../../stores/commun/store-compte-utilisateur'

describe('FacturationDocuments.vue', () => {
    /**
     * @type { import('@vue/test-utils').VueWrapper }
     */
    let wrapper = null
    let mockGet = null
    let mockPost = null
    let mockPatch = null

    beforeEach(async () => {
        global.window.scrollTo = vi.fn()
        global.IntersectionObserver = vi.fn(() => {
          return {
              observe: vi.fn(),
              unobserve: vi.fn(),
              disconnect: vi.fn(),
          }
        })

        mockGet = vi.fn().mockImplementation((url) => {
          if (/facturationDocuments\/next-num\/devis/.test(url)) {
            return Promise.resolve({ data: { items: [{ nextNum: 'D001' }] } })
          }
    
          if (/facturationDocuments\/111-111/.test(url)) {
            return Promise.resolve({ data: documentDetail })
          }
    
          if (/facturationClients\/001/.test(url)) {
            return Promise.resolve({ data: clientDetail })
          }

          if (/facturationAdherents\/(001|D\d+)/.test(url)) {
            return Promise.resolve({ data: { items: [{ email: 'test1@gmail.com' }] } })
          }

          if (/facturationClients\/002/.test(url)) {
            return Promise.resolve({ data: { items: [{ email: '' }] } })
          }
    
          if (/facturationModeles\/(devis|bl|facture|avoir)/.test(url)) {
            return Promise.resolve({ data: modeles })
          }

          if (/facturationDocuments\/numerotations/.test(url)) {
            return Promise.resolve({ data: numerotations })
          }

          if (/facturationDocuments/.test(url)) {
            // copier le donees test pour eviter la pollution du state a cause du $patch
            return Promise.resolve({ data: JSON.parse(JSON.stringify(documents)) })
          }

          if (/facturationGenerationDocuments\/pdf\/telecharger/.test(url)) {
            return Promise.resolve({ data: { text: () => '{}' }, headers: {}})
          }

          if (/comptaParametrage\/parametres\/recuperer/.test(url)) {
            return Promise.resolve({ data: { items: {
              parametres: {
                dateDebutExercice: '2023-01-01',
              },
              details: {}
            }}})
          }

          if (/gateway\/adminComptes\/001/.test(url)) {
            return Promise.resolve({ data: userDemo })
          }

          if (/gateway\/facturationParametres/.test(url)) {
            return Promise.resolve({ data: parametres })
          }
    
          return Promise.resolve({ data: { items: [] } })
        })

        mockPost = vi.fn().mockImplementation((url) => {
          if (/facturationDocuments\/supprimer/.test(url)) {
            return Promise.resolve()
          }
    
          if (/facturationDocuments\/dupliquer/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationDocuments\/valider/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationDocuments\/transformer/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationGenerationDocuments\/pdf/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationDocuments\/taches/.test(url)) {
            return Promise.resolve()
          }

          return Promise.reject()
        })

        mockPatch = vi.fn().mockImplementation((url) => {
          if (/facturationDocuments\/statutEnvoie\/modifier/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationDocuments\/payer/.test(url)) {
            return Promise.resolve()
          }

          if (/facturationDocuments\/valider/.test(url)) {
            return Promise.resolve()
          }
    
          return Promise.reject()
        })

        vi.spyOn(axiosApi, 'get').mockImplementation((url) => {
          return mockGet(url)
        })

        setActivePinia(createPinia())

        wrapper = mount(FacturationDocuments, {
            global: {
              plugins: [ 
                mckitui,
                dayjs,
                store,
                router,
              ],
              stubs: {
                'mc-input': true,
                'mc-input-montant': true
              },
              provide: {
                axios: {
                  get: mockGet,
                  post: mockPost,
                  patch: mockPatch,
                }
              }
            },
            props: {
              facturationDocumentsType: 'devis'
            }
        })

        // attendre que tous les APIs soient charges
        await flushPromises()
    })

    afterEach(() => {
      vi.clearAllMocks()
    })

    it('ouvrir le panel de creation de document', async () => {
        expect(wrapper).toBeTruthy()

        const dashboardCreerActionWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
        const documentModeleAffichageWrapper = wrapper.findComponent({ name: 'documents-modele-affichage' })
        
        expect(dashboardCreerActionWrapper.exists()).toBe(true)
        expect(dashboardCreerActionWrapper.props('documentsDashboardType')).toBe('devis')

        expect(documentModeleAffichageWrapper.exists()).toBe(true)
        expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(false)

        await dashboardCreerActionWrapper.vm.$emit('documentsDashboardCreerEmise', 'devis')
        await flushPromises()

        expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(true)
    })

    it('recharger la liste des documents quand on selectionne un statut document', async () => {
        expect(wrapper).toBeTruthy()

        const storeFD = useFacturationDocumentsStore()
        const recupererDocumentsSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

        const dashboardStatutActionWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
        
        expect(dashboardStatutActionWrapper.exists()).toBe(true)
        expect(recupererDocumentsSpy).not.toHaveBeenCalled()

        await dashboardStatutActionWrapper.vm.$emit('documentsDashboardStatutEmise')

        expect(recupererDocumentsSpy).toHaveBeenCalledOnce()
    })

    it('recharger la liste des documents quand on applique les filtres', async () => {
        expect(wrapper).toBeTruthy()

        const storeFD = useFacturationDocumentsStore()

        // des filtres par defaut sont appliques au chargement du composant
        expect(storeFD.state__facturationDocuments_documentsFiltre).toEqual({
          fields: expect.any(String),
          client: null,
          statut: null,
          date_min: '01/01/2023', // valeur par defaut date debut exercice
          date_max: expect.any(String), // date du jour
          date_min_echeance: null,
          date_max_echeance: null,
          documents: null,
          famille_client: null,
          offset: 10,
          limit: 15,
          moyen_paiement: null,
          sort: null,
          statut_paiement: null,
          types: 'devis',
        })

        const recupererDocumentsSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

        const dashboardTableauWrapper = wrapper.findComponent({ name: 'documents-filtres' })
        
        expect(dashboardTableauWrapper.exists()).toBe(true)
        expect(recupererDocumentsSpy).not.toHaveBeenCalled()

        await dashboardTableauWrapper.vm.$emit('documentsFiltresRechargerTableau')

        expect(recupererDocumentsSpy).toHaveBeenCalledOnce()
    })

    it('selectionner tous les documents depuis le tableau', async () => {
      expect(wrapper).toBeTruthy()
  
      const storeFD = useFacturationDocumentsStore()
  
      storeFD.$patch({
        state__facturationDocuments_liste: { items: [
          { uuid: '001', suiviExist: '1', statutPaiement: true, statutEnvoi: '1', statut: 'en cours', type: 'devis'},
          { uuid: '002', suiviExist: '0', statutPaiement: false, statutEnvoi: '0', statut: 'valide', type: 'facture' }
        ]},
        state__facturationDocuments_documentSelections: [],
      })
  
      const tableauWrapper = wrapper.getComponent({ name: 'documents-tableau' })
      await tableauWrapper.vm.$emit('documentsTableauChoisirTousEmise', true)
  
      expect(storeFD.state__facturationDocuments_documentSelections).toEqual(['001', '002'])
      expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual({
        types: { devis: 1, facture: 1 },
        valide: 1,
        paye: 1,
        suivi: 1,
        envoye: 1,
      })

      await tableauWrapper.vm.$emit('documentsTableauChoisirTousEmise', false)
  
      expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
      expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual({
        types: { devis: 0, facture: 0 },
        valide: 0,
        paye: 0,
        suivi: 0,
        envoye: 0,
      })
    })

    it('ouvrir le panel de document en mode edition quand on edit un document', async () => {
        expect(wrapper).toBeTruthy()

        const storeFD = useFacturationDocumentsStore()
        expect(storeFD.state__facturationDocuments_documentCourant).toBeFalsy()

        const dashboardTableauWrapper = wrapper.findComponent({ name: 'documents-tableau' })
        const documentModeleAffichageWrapper = wrapper.findComponent({ name: 'documents-modele-affichage' })
        
        expect(dashboardTableauWrapper.exists()).toBe(true)
        expect(documentModeleAffichageWrapper.exists()).toBe(true)
        expect(documentModeleAffichageWrapper.props('documentsModeleAffichageMode')).toBe('creation')

        await dashboardTableauWrapper.vm.$emit('documentsTableauEditerEmise', { index: 0, document: documents.items[0] })
        // attendre que le promesse recuperer document soit resolu
        await flushPromises()

        expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(true)
        expect(documentModeleAffichageWrapper.props('documentsModeleAffichageMode')).toBe('edition')
    })

    it('ouvrir le panel de document en mode edition quand on edit un document depuis menu flottant', async () => {
      expect(wrapper).toBeTruthy()

      const storeFD = useFacturationDocumentsStore()
      storeFD.$patch({
        state__facturationDocuments_documentSelections: ['111-111'],
      })

      const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })
      const documentModeleAffichageWrapper = wrapper.findComponent({ name: 'documents-modele-affichage' })
      
      expect(menuFlottantWrapper.exists()).toBe(true)
      expect(documentModeleAffichageWrapper.exists()).toBe(true)
      expect(documentModeleAffichageWrapper.props('documentsModeleAffichageMode')).toBe('creation')

      await menuFlottantWrapper.vm.$emit('documentsTableauMenuFlottantEditerEmise')
      
      await flushPromises()

      expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])

      expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(true)
      expect(documentModeleAffichageWrapper.props('documentsModeleAffichageMode')).toBe('edition')
  })

    it('recuperer le numero suivant du document quand on ouvre en mode creation', async () => {
      expect(wrapper).toBeTruthy()
      const dashboardCreerActionWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
      
      expect(dashboardCreerActionWrapper.exists()).toBe(true)
      
      const storeFD = useFacturationDocumentsStore()
      const storeFM = useFacturationModelesStore()
      const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererNumeroSuivant')
      const recupererModeleSpy = vi.spyOn(storeFM, 'action__facturationModeles_recupererModele').mockResolvedValue()

      await dashboardCreerActionWrapper.vm.$emit('documentsDashboardCreerEmise', 'devis')
      
      expect(recupererDocumentSpy).toHaveBeenCalledOnce()
      expect(recupererDocumentSpy).toHaveBeenCalledWith('devis')

      expect(recupererModeleSpy).toHaveBeenCalledOnce()
      expect(recupererModeleSpy).toHaveBeenCalledWith('devis')
    })

    it('ne pas recuperer le numero suivant du document quand on ouvre en mode creation et le type de document est avoir ou facture', async () => {
      expect(wrapper).toBeTruthy()
      const dashboardCreerActionWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
      
      expect(dashboardCreerActionWrapper.exists()).toBe(true)
      
      const storeFD = useFacturationDocumentsStore()
      const storeFM = useFacturationModelesStore()
      const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererNumeroSuivant')
      const recupererModeleSpy = vi.spyOn(storeFM, 'action__facturationModeles_recupererModele').mockResolvedValue()

      await dashboardCreerActionWrapper.vm.$emit('documentsDashboardCreerEmise', 'avoir')
      
      expect(recupererDocumentSpy).not.toHaveBeenCalled()

      expect(recupererModeleSpy).toHaveBeenCalledOnce()
      expect(recupererModeleSpy).toHaveBeenCalledWith('avoir')
    })

    it('autoriser de modifier seulement le document en cours', async () => {
      expect(wrapper).toBeTruthy()

      const storeFD = useFacturationDocumentsStore()
      expect(storeFD.state__facturationDocuments_documentCourant).toBeFalsy()

      const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererDetailDocument')

      const dashboardTableauWrapper = wrapper.getComponent({ name: 'documents-tableau' })
      const documentModeleAffichageWrapper = wrapper.getComponent({ name: 'documents-modele-affichage' })

      await dashboardTableauWrapper.vm.$emit('documentsTableauEditerEmise', { index: 0, document: { ...documents.items[0], statut: 'valide' } })

      expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(false)
      expect(documentModeleAffichageWrapper.props('documentsModeleAffichageMode')).toBe('creation')

      expect(recupererDocumentSpy).not.toHaveBeenCalled()
  })

  it('recuperer le parametre de document au chargement', async () => {
    expect(wrapper).toBeTruthy()
    
    const storeFP = useFacturationParametresStore()
    expect(storeFP.state__facturationParametres_parametre).toEqual(parametres.items[0])
  })

  it(`ouvrir le menu flottant desqu'il y a un document selectionne`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.exists()).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(false)

    const storeFD = useFacturationDocumentsStore()

    documents.items.forEach(item => {
      storeFD.$patch(state => {
        state.state__facturationDocuments_documentSelections.push(item.uuid)
      })
    })

    await wrapper.vm.$nextTick()

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantNombreDocument')).toBe(2)

    storeFD.$patch({ state__facturationDocuments_documentSelections: []})

    await wrapper.vm.$nextTick()

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantNombreDocument')).toBe(0)
  })

  it(`gerer l'affichage du bouton valider`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonValiderVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagValiderActif')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_actionbarConfigurations.valide = 1
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonValiderVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagValiderActif')).toBe(false)
  })

  it(`gerer l'affichage du bouton transformer`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonTransformerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagTransformerActif')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.valide = 1
      state.state__facturationDocuments_actionbarConfigurations.types = { facture: 2 }
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonTransformerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagTransformerActif')).toBe(false)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.types = { devis: 1, facture: 1 }
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonTransformerVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagTransformerActif')).toBe(false)
  })

  it(`gerer l'affichage du bouton supprimer`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSupprimerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSupprimerActif')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_actionbarConfigurations.valide = 1
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSupprimerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSupprimerActif')).toBe(false)
  })

  it(`gerer l'affichage du bouton dupliquer`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonDupliquerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagDupliquerActif')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_actionbarConfigurations.valide = 1
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonDupliquerVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagDupliquerActif')).toBe(true)
  })

  it(`gerer l'affichage du bouton suivi email`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSuiviVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSuiviActif')).toBe(false)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001']
      state.state__facturationDocuments_actionbarConfigurations.suivi = 0
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSuiviVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSuiviActif')).toBe(false)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001']
      state.state__facturationDocuments_actionbarConfigurations.suivi = 1
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSuiviVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSuiviActif')).toBe(true)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.suivi = 1
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantBoutonSuiviVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantInfoTagSuiviActif')).toBe(true)
  })

  it(`gerer l'affichage du toggle statut paiement`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutPaiementVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.paye = 0
      state.state__facturationDocuments_actionbarConfigurations.types = { facture: 2 }
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutPaiementVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(false)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.paye = 2
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutPaiementVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(true)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.paye = 1 // documents avec statut paiement different
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutPaiementVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(false)
  })

  it(`gerer l'affichage du toggle statut d'envoi`, async () => {
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutEnvoiVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(true)

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.envoye = 0
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutEnvoiVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(false)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.envoye = 2
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutEnvoiVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(true)

    storeFD.$patch(state => {
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations.envoye = 1 // documents avec statut envoi different
    })
    await wrapper.vm.$nextTick()
    
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantToggleStatutEnvoiVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(false)
  })

  it('supprimer un document depuis le tableau', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [{ uuid: '001', statut: 'en cours'}] },
      state__facturationDocuments_documentSelections: ['001'],
    })

    const tableauWrapper = wrapper.getComponent({ name: 'documents-tableau' })
    const dbSupprimer = wrapper.findComponent({ name: 'documents-db-supprimer' })

    expect(dbSupprimer.exists()).toBe(true)
    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual([])

    await tableauWrapper.vm.$emit('documentsTableauSupprimerEmise', { index: 0, document: { uuid: '001', statut: 'en cours' } })

    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(true)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual(['001'])
  })

  it('supprimer un document depuis le tableau ne doit pas afficher le dialogbox si le document est valide', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [{ uuid: '001', statut: 'valide'}] },
      state__facturationDocuments_documentSelections: ['001'],
    })

    const tableauWrapper = wrapper.getComponent({ name: 'documents-tableau' })
    const dbSupprimer = wrapper.findComponent({ name: 'documents-db-supprimer' })

    expect(dbSupprimer.exists()).toBe(true)
    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual([])

    await tableauWrapper.vm.$emit('documentsTableauSupprimerEmise', { index: 0, document: { uuid: '001', statut: 'valide' } })

    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual([])
  })

  it('supprimer de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [{ uuid: '001', statut: 'en cours'}, { uuid: '002', statut: 'en cours'}] },
      state__facturationDocuments_documentSelections: ['001', '002'],
    })

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })
    const dbSupprimer = wrapper.findComponent({ name: 'documents-db-supprimer' })

    expect(dbSupprimer.exists()).toBe(true)
    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual([])

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantSupprimerEmise')

    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(true)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual(['001', '002'])

    await dbSupprimer.vm.$emit('documentsDbSupprimerFermerEmise')

    expect(dbSupprimer.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimer.props('documentsDbSupprimerUuids')).toEqual([])
  })

  it('valider de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_actionbarConfigurations = {
        types: { devis: 1 }
      }
    })
    
    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })
    const dbValider = wrapper.findComponent({ name: 'documents-db-valider' })

    expect(dbValider.exists()).toBe(true)
    expect(dbValider.props('documentsDbValiderVisible')).toBe(false)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantValiderEmise')

    expect(dbValider.props('documentsDbValiderVisible')).toBe(true)
    
    // attentre que le modal s'affiche correctement avant de fermer
    // on devrait attendre quelque seconde avant de fermer pour eviter l'erreur du a nextTick dans mc-dialogbox
    await wrapper.vm.$nextTick()
    await dbValider.vm.$emit('documentsDbValiderFermerEmise')

    expect(dbValider.props('documentsDbValiderVisible')).toBe(false)
  })

  it('valider un document a 0 euro ne devrait pas etre autoriser', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_liste = {
        items: [
          { uuid: '001', type: 'devis', totalHt: 0, totalTtc: 0, totalTva: 0 },
          { uuid: '002', type: 'devis', totalHt: 20, totalTtc: 24, totalTva: 4 },
        ]
      }
      state.state__facturationDocuments_documentSelections = ['001', '002']
      state.state__facturationDocuments_actionbarConfigurations = {
        types: { devis: 2 }
      }
    })
    
    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })
    const dbValider = wrapper.findComponent({ name: 'documents-db-valider' })

    expect(dbValider.exists()).toBe(true)
    expect(dbValider.props('documentsDbValiderVisible')).toBe(false)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantValiderEmise')

    expect(dbValider.props('documentsDbValiderVisible')).toBe(false)
  })

  it('dupliquer de document depuis le menu flottant', async () => {
    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_actionbarConfigurations = {
        types: { devis: 1 }
      }
    })
    
    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })
    const dbDupliquer = wrapper.getComponent({ name: 'documents-db-dupliquer' })

    expect(dbDupliquer.exists()).toBe(true)
    expect(dbDupliquer.props('documentsDbDupliquerVisible')).toBe(false)

    const recupererNumeroDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererNumeroSuivant')

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantDupliquerEmise')

    await flushPromises()
    
    expect(recupererNumeroDocumentSpy).not.toHaveBeenCalled()

    expect(dbDupliquer.props('documentsDbDupliquerVisible')).toBe(true)
    
    // attentre que le modal s'affiche correctement avant de fermer
    // on devrait attendre quelque seconde avant de fermer pour eviter l'erreur du a nextTick dans mc-dialogbox
    await wrapper.vm.$nextTick()
    await dbDupliquer.vm.$emit('documentsDbDupliquerFermerEmise')

    expect(dbDupliquer.props('documentsDbDupliquerVisible')).toBe(false)
  })

  it('transformer de document depuis le menu flottant', async () => {
    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })
    const dbTransformer = wrapper.getComponent({ name: 'documents-db-transformer' })

    expect(dbTransformer.exists()).toBe(true)
    expect(dbTransformer.props('documentsDbTransformerVisible')).toBe(false)

    const storeFD = useFacturationDocumentsStore()
    const recupererNumeroDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererNumeroSuivant')

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantTransformerEmise')

    await flushPromises()
    
    expect(recupererNumeroDocumentSpy).not.toHaveBeenCalled()

    expect(dbTransformer.props('documentsDbTransformerVisible')).toBe(true)
    
    // attentre que le modal s'affiche correctement avant de fermer
    // on devrait attendre quelque seconde avant de fermer pour eviter l'erreur du a nextTick dans mc-dialogbox
    await wrapper.vm.$nextTick()
    await dbTransformer.vm.$emit('documentsDbTransformerFermerEmise')

    expect(dbTransformer.props('documentsDbTransformerVisible')).toBe(false)
  })

  it('marquer comme envoye de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: {
        items: [
          {
            uuid: '001',
            statut: 'en cours',
            statutEnvoi: '0'
          },
          {
            uuid: '002',
            statut: 'en cours',
            statutEnvoi: '0'
          }
        ]
      },
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        envoye: 0
      }
    })
    await wrapper.vm.$nextTick()

    const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(false)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutEnvoiEmise', true)

    await flushPromises()

    expect(mockPatch).toHaveBeenCalledOnce()

    expect(recupererDocumentSpy).not.toHaveBeenCalled()

    expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
      items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutEnvoi: '1'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutEnvoi: '1'
        }
      ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      envoye: 0
    }))
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(true)
  })

  it('marquer comme non envoyer de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutEnvoi: '1'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutEnvoi: '1'
        }
      ]},
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        envoye: 2
      }
    })
    await wrapper.vm.$nextTick()

    const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(true)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutEnvoiEmise', false)

    await flushPromises()

    expect(mockPatch).toHaveBeenCalledOnce()

    expect(recupererDocumentSpy).not.toHaveBeenCalled()

    expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
      items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutEnvoi: '0'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutEnvoi: '0'
        }
      ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      envoye: 0
    }))

    // reste l'etat initiale
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(true)
  })

  it('marquer comme paye de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
          {
            uuid: '001',
            statut: 'en cours',
            statutPaiement: false,
            type: 'devis',
            date: '2024-01-01'
          },
          {
            uuid: '002',
            statut: 'en cours',
            statutPaiement: false,
            type: 'devis',
            date: '2024-01-01'
          }
        ]
      },
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        paye: 0
      }
    })
    await wrapper.vm.$nextTick()
    const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(false)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutPaiementEmise', true)

    await flushPromises()

    expect(mockPatch).toHaveBeenCalledOnce()

    expect(recupererDocumentSpy).not.toHaveBeenCalled()

    expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
      items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutPaiement: true,
          type: 'devis',
          date: '2024-01-01'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutPaiement: true,
          type: 'devis',
          date: '2024-01-01'
        }
      ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      paye: 0
    }))
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(true)
  })

  it('marquer comme non payer de document depuis le menu flottant', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutPaiement: true,
          type: 'devis',
          date: '2024-01-01'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutPaiement: true,
          type: 'devis',
          date: '2024-01-01'
        }
      ]},
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        paye: 2
      }
    })
    await wrapper.vm.$nextTick()

    const recupererDocumentSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })

    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(true)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutPaiementEmise', false)

    await flushPromises()

    expect(mockPatch).toHaveBeenCalledOnce()

    expect(recupererDocumentSpy).not.toHaveBeenCalled()

    expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
      items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutPaiement: false,
          type: 'devis',
          date: '2024-01-01'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutPaiement: false,
          type: 'devis',
          date: '2024-01-01'
        }
      ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      paye: 0
    }))
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(true)
  })

  it(`reinitialiser le statut du bouton toggle dans le menu flottant quand l'execution de l'operation echoue`, async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutPaiement: false,
          statutEnvoi: '0',
          type: 'facture'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutPaiement: false,
          statutEnvoi: '0',
          type: 'facture'
        }
      ]},
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        types: { facture: 2 },
        envoye: 0,
        paye: 0
      }
    })
    await wrapper.vm.$nextTick()

    const modifierDocumentStatutEnvoiSpy = vi.spyOn(storeFD, 'action__facturationDocuments_modifierStatutEnvoiDocument').mockRejectedValue(new Error(`Erreur de modification du statut d'envoi`))
    const modifierDocumentStatutPaiementSpy = vi.spyOn(storeFD, 'action__facturationDocuments_modifierStatutPaiementFacture').mockRejectedValue(new Error('Erreur de modification du statut de paiement'))

    const menuWrapper = wrapper.getComponent({ name: 'documents-tableau-menu-flottant' })

    // statut d'envoi
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(false)
    expect(menuWrapper.props('documentsTableauMenuFlottantToggleReinitialisationNombre')).toEqual(0)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutEnvoiEmise', true)
    await flushPromises()

    expect(modifierDocumentStatutEnvoiSpy).toHaveBeenCalledOnce()
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutEnvoi')).toBe(false)
    expect(menuWrapper.props('documentsTableauMenuFlottantToggleReinitialisationNombre')).toEqual(1)

    // statut de paiement
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(false)

    await menuWrapper.vm.$emit('documentsTableauMenuFlottantStatutPaiementEmise', true)
    await flushPromises()

    expect(modifierDocumentStatutPaiementSpy).toHaveBeenCalledOnce()
    expect(menuWrapper.props('documentsTableauMenuFlottantStatutPaiement')).toBe(false)
    expect(menuWrapper.props('documentsTableauMenuFlottantToggleReinitialisationNombre')).toEqual(2)

    // les stores ne devraient pas etre toucher
    expect(storeFD.state__facturationDocuments_documentSelections).toEqual(['001', '002'])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
      items: [
        {
          uuid: '001',
          statut: 'en cours',
          statutPaiement: false,
          statutEnvoi: '0',
          type: 'facture'
        },
        {
          uuid: '002',
          statut: 'en cours',
          statutPaiement: false,
          statutEnvoi: '0',
          type: 'facture'
        }
      ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      types: { facture: 2 },
        envoye: 0,
        paye: 0
    }))
  })

  it('generer de pdf de document en ouvrant le modal si aucun de document en selection', async () => {
    expect(wrapper).toBeTruthy()
    
    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbGenererPdfWrapper = wrapper.findComponent({ name: 'documents-db-generer-pdf' })

    expect(dbGenererPdfWrapper.exists()).toBe(true)
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)

    await actionWrapper.vm.$emit('documentsTableauActionGenererPdfEmise')

    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(true)
    
    await wrapper.vm.$nextTick()
    await dbGenererPdfWrapper.vm.$emit('documentsDbGenererPdfFermerEmise')

    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
  })

  it('generer de pdf de document si moins de 10 documents en selection', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    // selection de 10 documents
    const documents = []
    for(let i = 0; i < 10; i++) {
      documents.push(`D000${i}`)
    }
    storeFD.$patch({ state__facturationDocuments_documentSelections: documents })
    await wrapper.vm.$nextTick()

    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbGenererPdfWrapper = wrapper.findComponent({ name: 'documents-db-generer-pdf' })

    expect(dbGenererPdfWrapper.exists()).toBe(true)
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)

    await actionWrapper.vm.$emit('documentsTableauActionGenererPdfEmise')

    await flushPromises()

    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)

    expect(mockPost).toHaveBeenCalledOnce()
    expect(mockPost).toHaveBeenCalledWith(
      expect.anything(),
      expect.objectContaining({
        documentsUuid: documents
      }),
      expect.anything()
    )

    expect(mockGet).lastCalledWith(
      expect.anything(),
      expect.objectContaining({
        params: {
          documentsUuid: documents.join(','),
          merge: true
        }
      }),
    )
  })

  it('imprimer de pdf de document si moins de 10 documents en selection', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()

    // selection de 10 documents
    const documents = []
    for(let i = 0; i < 10; i++) {
      documents.push(`D000${i}`)
    }
    storeFD.$patch({ state__facturationDocuments_documentSelections: documents })
    await wrapper.vm.$nextTick()

    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbGenererPdfWrapper = wrapper.findComponent({ name: 'documents-db-generer-pdf' })

    expect(dbGenererPdfWrapper.exists()).toBe(true)
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)

    await actionWrapper.vm.$emit('documentsTableauActionImprimerEmise')

    await flushPromises()

    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)

    expect(mockPost).toHaveBeenCalledOnce()
    expect(mockPost).toHaveBeenCalledWith(
      expect.anything(),
      expect.objectContaining({
        documentsUuid: documents
      }),
      expect.anything()
    )

    expect(mockGet).lastCalledWith(
      expect.anything(),
      expect.objectContaining({
        params: {
          documentsUuid: documents.join(','),
          merge: true
        }
      }),
    )
  })

  it(`reinitialiser la selection et modifier directement la liste en cas d'export`, async () => {
    expect(wrapper).toBeTruthy()
    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch({
        state__facturationDocuments_liste: { items: [
            {
                uuid: '001',
                statut: 'en cours',
                type: 'devis',
            },
            {
                uuid: '002',
                statut: 'en cours',
                type: 'devis',
            }
        ]},
        state__facturationDocuments_documentSelections: ['001', '002'],
        state__facturationDocuments_actionbarConfigurations: {
            types: { devis: 2 }
        }
    })
    const dbGenererPdfWrapper = wrapper.getComponent({ name: 'documents-db-generer-pdf' })

    await dbGenererPdfWrapper.vm.$emit('documentsDbGenererPdfFermerEmise', true)
    
    await wrapper.vm.$nextTick()
    
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
    expect(storeFD.state__facturationDocuments_documentSelections).toEqual([])
    expect(storeFD.state__facturationDocuments_liste).toEqual(expect.objectContaining({
        items: [
            {
                uuid: '001',
                statut: 'en cours',
                type: 'devis',
                isLock: true,
                lastGeneration: expect.any(String),
                lockTime: expect.any(String),
            },
            {
                uuid: '002',
                statut: 'en cours',
                type: 'devis',
                isLock: true,
                lastGeneration: expect.any(String),
                lockTime: expect.any(String),
            }
        ]
    }))
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual({
        types: { devis: 0 },
        envoye: 0,
        valide: 0,
        suivi: 0,
        paye: 0
    })
  })

  it('envoyer mail de document', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()
    const storeFGD = useFacturationGenerationDocumentsStore()
    const storeCU = useCompteUtilisateurStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        { uuid: '001', suiviExist: '0', statutEnvoi: '0', type: 'devis'},
        { uuid: '002', suiviExist: '0', statutEnvoi: '0', type: 'devis'},
      ] },
      state__facturationDocuments_documentSelections: ['001', '002'],
      state__facturationDocuments_actionbarConfigurations: {
        types: { devis: 2 },
        envoye: 0,
        suivi: 0,
      }
    })
    storeFGD.$patch({
      state__facturationGenerationDocuments_pdfGeneres: [
        { documentUuid: '0001', nom: 'Devis_001.pdf', base64: 'base64....', extension: 'pdf'},
        { documentUuid: '0002', nom: 'Devis_002.pdf', base64: 'base64....', extension: 'pdf'},
      ]
    })
    await wrapper.vm.$nextTick()
    
    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbEnvoyerMailWrapper = wrapper.findComponent({ name: 'documents-db-envoyer-mail' })

    expect(dbEnvoyerMailWrapper.exists()).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)
    expect(storeCU.state__compteUtilisateur_detail).toBeNull()

    await actionWrapper.vm.$emit('documentsTableauActionEnvoyerMailEmise')
    await flushPromises()

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(true)
    expect(storeCU.state__compteUtilisateur_detail).toEqual(userDemo)
    
    await wrapper.vm.$nextTick()
    await dbEnvoyerMailWrapper.vm.$emit('documentsDbEnvoyerMailFermerEmise', true)

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)

    expect(storeFD.state__facturationDocuments_documentSelections).toEqual(['001', '002'])
    expect(storeFD.state__facturationDocuments_actionbarConfigurations).toEqual(expect.objectContaining({
      types: { devis: 2 },
      envoye: 2,
      suivi: 2,
      paye: 0,
      valide: 0,
    }))
    expect(storeFGD.state__facturationGenerationDocuments_pdfGeneres).toEqual([])
  })

  it('envoyer mail sans selection de document ou plus de 50 documents ne devrait pas ouvrir le modal', async () => {
    expect(wrapper).toBeTruthy()
    
    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbEnvoyerMailWrapper = wrapper.findComponent({ name: 'documents-db-envoyer-mail' })

    expect(dbEnvoyerMailWrapper.exists()).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)

    // envoi mail sans selection
    await actionWrapper.vm.$emit('documentsTableauActionEnvoyerMailEmise')
    await flushPromises()

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)

    // envoi mail avec plus de 50 documents
    const storeFD = useFacturationDocumentsStore()
    const documents = []
    for(let i = 0; i < 51; i++) {
      documents.push(`D000${i}`)
    }
    storeFD.$patch({ state__facturationDocuments_documentSelections: documents })
    await wrapper.vm.$nextTick()

    await actionWrapper.vm.$emit('documentsTableauActionEnvoyerMailEmise')
    await flushPromises()

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)
  })

  it(`verifier email de partenaire avant d'envoyer le mail de documents`, async () => {
    expect(wrapper).toBeTruthy()

    // preparer
    const storeFD = useFacturationDocumentsStore()
    const storeFC = useFacturationClientsStore()
    const storeFA = useFacturationAdherentsStore()
    const storeCU = useCompteUtilisateurStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        { uuid: '001', id: 1, partenaireUuid: '001'},
        { uuid: '002', id: 2, partenaireUuid: '002'},
      ] },
      state__facturationDocuments_documentSelections: ['001', '002']
    })

    storeFA.$patch({ state__facturationAdherents_liste: [
      { value: '001', type: 'adherent', label: 'Adherent 1' }
    ] })

    storeFC.$patch({ state__facturationClients_liste: [
      { value: '002', type: 'client', label: 'Client 1' }
    ] })

    await wrapper.vm.$nextTick()
    
    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    let dbEnvoyerMailWrapper = wrapper.getComponent({ name: 'documents-db-envoyer-mail' })

    expect(dbEnvoyerMailWrapper.exists()).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailPartenairesGroupe')).toEqual({})
    expect(storeCU.state__compteUtilisateur_detail).toBeNull()

    await actionWrapper.vm.$emit('documentsTableauActionEnvoyerMailEmise')
    await flushPromises()

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailPartenairesGroupe')).toEqual({
      '001': {
        documents: [{ uuid: '001', id: 1 }],
        detail: {
          email: 'test1@gmail.com'
        },
        libelle: 'Adherent 1'
      },
      '002': {
        documents: [{ uuid: '002', id: 2 }],
        detail: {
          email: ''
        },
        libelle: 'Client 1'
      }
    })
    expect(storeCU.state__compteUtilisateur_detail).toEqual(userDemo)
    
    await dbEnvoyerMailWrapper.vm.$emit('documentsDbEnvoyerMailFermerEmise')
    await wrapper.vm.$nextTick()

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)
  })

  it('telecharger les documents en pdf (base64) si moins de 10 documents et si et seulement le meme partenaire', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()
    const storeFA = useFacturationAdherentsStore()
    const storeFC = useFacturationClientsStore()

    storeFD.$patch({
      state__facturationDocuments_liste: { items: [
        { uuid: '001', id: 1, partenaireUuid: '001'},
        { uuid: '002', id: 2, partenaireUuid: 'D001'},
        { uuid: '003', id: 3, partenaireUuid: 'D001'},
      ] },
      state__facturationDocuments_documentSelections: ['001', '002', '003'],
    })
    storeFC.$patch({ state__facturationClients_liste: [
      { value: '001', type: 'client', label: 'Client 1' }
    ] })
    storeFA.$patch({ state__facturationAdherents_liste: [
      { value: 'D001', type: 'adherent', label: 'Adherent 1' }
    ] })

    const storeFGD = useFacturationGenerationDocumentsStore()
    const genererPdf = vi.spyOn(storeFGD, 'action__facturationGenerationDocuments_genererPdf').mockResolvedValue()
    const telechargerPdf = vi.spyOn(storeFGD, 'action__facturationGenerationDocuments_telechargerListe').mockResolvedValue()
    
    const actionWrapper = wrapper.getComponent({ name: 'documents-tableau-action' })
    const dbEnvoyerMailWrapper = wrapper.findComponent({ name: 'documents-db-envoyer-mail' })

    expect(dbEnvoyerMailWrapper.exists()).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)

    await actionWrapper.vm.$emit('documentsTableauActionEnvoyerMailEmise')
    await flushPromises()

    expect(genererPdf).toHaveBeenCalledOnce()
    expect(genererPdf).toHaveBeenCalledWith(['001', '002', '003'])

    expect(telechargerPdf).toHaveBeenCalledOnce()
    expect(telechargerPdf).toHaveBeenCalledWith(['001', '002', '003'], false, false, false, true)

    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailPartenairesGroupe')).toEqual({
      '001': {
        documents: [{ uuid: '001', id: 1 }],
        detail: expect.objectContaining({
          email: 'cp000@test.com'
        }),
        libelle: 'Client 1',
      },
      'D001': {
        documents: [
          {uuid: '002', id: 2},
          {uuid: '003', id: 3},
        ],
        detail: expect.objectContaining({
          email: 'test1@gmail.com'
        }),
        libelle: 'Adherent 1'
      },
    })
  })

  it('Fermer le menu flottant en ouvrant le panel de creation de document', async () => {
    expect(wrapper).toBeTruthy()

    const dashboardCreerActionWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
    const documentModeleAffichageWrapper = wrapper.findComponent({ name: 'documents-modele-affichage' })
    const documentsTableauMenuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })
    
    expect(dashboardCreerActionWrapper.exists()).toBe(true)
    expect(dashboardCreerActionWrapper.props('documentsDashboardType')).toBe('devis')

    expect(documentModeleAffichageWrapper.exists()).toBe(true)
    expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(false)

    expect(documentsTableauMenuFlottantWrapper.exists()).toBeTruthy()

    await dashboardCreerActionWrapper.vm.$emit('documentsDashboardCreerEmise', 'devis')
    await flushPromises()

    expect(documentModeleAffichageWrapper.props('documentsModeleAffichageVisible')).toBe(true)
    expect(documentsTableauMenuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBeFalsy()
  })

  it(`executer les operations pour un document venant du panel d'affichage`, async () => {
    expect(wrapper).toBeTruthy()

    const documentModeleAffichageWrapper = wrapper.findComponent({ name: 'documents-modele-affichage' })
    expect(documentModeleAffichageWrapper.exists()).toBe(true)
    expect(documentModeleAffichageWrapper.props('documentsModeleAffichageDocumentCourantModifieNombre')).toEqual(0)

    // valider un document
    const dbValiderWrapper = wrapper.findComponent({ name: 'documents-db-valider' })
    expect(dbValiderWrapper.props('documentsDbValiderVisible')).toBe(false)
    expect(dbValiderWrapper.props('documentsDbValiderUuids')).toEqual([])
    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageValiderEmise', { uuid: '0001', statut: 'en cours', type: 'devis' })
    expect(dbValiderWrapper.props('documentsDbValiderVisible')).toBe(true)
    expect(dbValiderWrapper.props('documentsDbValiderUuids')).toEqual(['0001'])
    await dbValiderWrapper.vm.$emit('documentsDbValiderFermerEmise', true)
    expect(documentModeleAffichageWrapper.props('documentsModeleAffichageDocumentCourantModifieNombre')).toEqual(1)

    // transformer un document
    const dbTransformerWrapper = wrapper.findComponent({ name: 'documents-db-transformer' })
    expect(dbTransformerWrapper.props('documentsDbTransformerVisible')).toBe(false)
    expect(dbTransformerWrapper.props('documentsDbTransformerUuids')).toEqual([])
    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageTransformerEmise', { uuid: '0001', statut: 'en cours', type: 'devis' })
    expect(dbTransformerWrapper.props('documentsDbTransformerVisible')).toBe(true)
    expect(dbTransformerWrapper.props('documentsDbTransformerUuids')).toEqual(['0001'])
    expect(dbTransformerWrapper.props('documentsDbTransformerType')).toEqual('devis')
    await dbTransformerWrapper.vm.$emit('documentsDbTransformerFermerEmise', true)
    expect(documentModeleAffichageWrapper.props('documentsModeleAffichageDocumentCourantModifieNombre')).toEqual(2)

    // imprimer un document
    const dbImprimerWrapper = wrapper.findComponent({ name: 'documents-db-generer-pdf' })
    expect(dbImprimerWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
    
    const storeFGD = useFacturationGenerationDocumentsStore()
    const genererPdf = vi.spyOn(storeFGD, 'action__facturationGenerationDocuments_genererPdf').mockResolvedValue()
    const telechargerPdf = vi.spyOn(storeFGD, 'action__facturationGenerationDocuments_telechargerListe').mockResolvedValue()

    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageImprimerEmise', { uuid: '0001', statut: 'en cours', type: 'devis' })
    await flushPromises()
    expect(dbImprimerWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
    expect(dbImprimerWrapper.props('documentsDbGenererPdfImprimer')).toBe(false) // car executer immediatement
    
    expect(genererPdf).toHaveBeenCalledOnce()
    expect(genererPdf).toHaveBeenCalledWith(['0001'])
    expect(telechargerPdf).toHaveBeenCalledOnce()
    expect(telechargerPdf).toHaveBeenCalledWith(['0001'], false, false, true)

    // generer pdf
    const dbGenererPdfWrapper = wrapper.findComponent({ name: 'documents-db-generer-pdf' })
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
    
    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageGenererPdfEmise', { uuid: '0001', statut: 'en cours', type: 'devis' })
    await flushPromises()
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfVisible')).toBe(false)
    expect(dbGenererPdfWrapper.props('documentsDbGenererPdfImprimer')).toBe(false)
    
    expect(genererPdf).toHaveBeenCalledTimes(2)
    expect(genererPdf).toHaveBeenLastCalledWith(['0001'])
    expect(telechargerPdf).toHaveBeenCalledTimes(2)
    expect(telechargerPdf).toHaveBeenLastCalledWith(['0001'], false, false, false)

    // envoyer email
    const dbEnvoyerMailWrapper = wrapper.findComponent({ name: 'documents-db-envoyer-mail' })
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(false)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailUuids')).toEqual([])
    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageEnvoyerMailEmise', { uuid: '001', statut: 'en cours', type: 'devis' })
    await flushPromises()
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailVisible')).toBe(true)
    expect(dbEnvoyerMailWrapper.props('documentsDbEnvoyerMailUuids')).toEqual(['001'])
    await dbEnvoyerMailWrapper.vm.$emit('documentsDbEnvoyerMailFermerEmise')
    // pas besoins de rafraichir pour l'instant
    // expect(documentModeleAffichageWrapper.props('documentsModeleAffichageDocumentCourantModifieNombre')).toEqual(3)
    
    // supprimer
    const dbSupprimerWrapper = wrapper.findComponent({ name: 'documents-db-supprimer' })
    expect(dbSupprimerWrapper.props('documentsDbSupprimerVisible')).toBe(false)
    expect(dbSupprimerWrapper.props('documentsDbSupprimerUuids')).toEqual([])
    await documentModeleAffichageWrapper.vm.$emit('documentsModeleAffichageSupprimerEmise', { uuid: '0001', statut: 'en cours', type: 'devis' })
    expect(dbSupprimerWrapper.props('documentsDbSupprimerVisible')).toBe(true)
    expect(dbSupprimerWrapper.props('documentsDbSupprimerUuids')).toEqual(['0001'])
  }),

  it('exporter la liste des documents en csv', async () => {
    const tableauActionWrapper = wrapper.findComponent({ name: 'documents-tableau-action' })

    const storeFD = useFacturationDocumentsStore()
    const exporterCsv = vi.spyOn(storeFD, 'action__facturationDocuments_exporterListeCsv').mockResolvedValue()

    await tableauActionWrapper.vm.$emit('documentsTableauActionExporterCsvEmise')
    await flushPromises()

    expect(exporterCsv).toHaveBeenCalledOnce()
  })

  it('exporter la liste des documents en pdf', async () => {
    const tableauActionWrapper = wrapper.findComponent({ name: 'documents-tableau-action' })
    
    const storeFD = useFacturationDocumentsStore()
    const exporterPdf = vi.spyOn(storeFD, 'action__facturationDocuments_exporterListePdf').mockResolvedValue()

    await tableauActionWrapper.vm.$emit('documentsTableauActionExporterPdfEmise')
    await flushPromises()

    expect(exporterPdf).toHaveBeenCalledOnce()
  })

  it(`avertir lorsque qu'il n'y a pas encore de numerotation configure alorque l'utilisateur souhaite creer un bl ou un devis`, async () => {
    const storeFN = useFacturationNumerotationsStore()
    storeFN.$patch(state => {
      state.state__facturationNumerotations_liste = {}
      state.state__facturationNumerotations_listeCharge = true
    })

    const dashboardWrapper = wrapper.findComponent({ name: 'documents-dashboard' })
    expect(dashboardWrapper.exists()).toBe(true)

    const numerotationDbAvertissementWrapper = wrapper.findComponent({ name: 'numerotations-db-avertissement' })
    expect(numerotationDbAvertissementWrapper.exists()).toBe(true)
    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(false)

    await dashboardWrapper.vm.$emit('documentsDashboardCreerEmise',  'devis')

    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(true)
    
    const creationDocumentPanel = wrapper.findComponent({ name: 'documents-modele-affichage' })
    expect(creationDocumentPanel.props('documentsModeleAffichageVisible')).toEqual(false)
  })

  it(`avertir lorsque qu'il n'y a pas encore de numerotation configure alorque l'utilisateur souhaite dupliquer un bl ou un devis`, async () => {
    const storeFN = useFacturationNumerotationsStore()
    storeFN.$patch(state => {
      state.state__facturationNumerotations_liste = {}
      state.state__facturationNumerotations_listeCharge = true
    })

    const menuFlottant = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })
    expect(menuFlottant.exists()).toBe(true)

    const numerotationDbAvertissementWrapper = wrapper.findComponent({ name: 'numerotations-db-avertissement' })
    expect(numerotationDbAvertissementWrapper.exists()).toBe(true)
    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(false)

    await menuFlottant.vm.$emit('documentsTableauMenuFlottantDupliquerEmise')

    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(true)
    
    const dbDupliquerWrapper = wrapper.findComponent({ name: 'documents-db-dupliquer' })
    expect(dbDupliquerWrapper.props('documentsDbDupliquerVisible')).toEqual(false)
  })

  it(`avertir lorsque qu'il n'y a pas encore de numerotation configure alorque l'utilisateur souhaite transformer un devis en bl`, async () => {
    const storeFN = useFacturationNumerotationsStore()
    storeFN.$patch({
      state__facturationNumerotations_liste: {},
      state__facturationNumerotations_listeCharge: true
    })

    const dbTransformerWrapper = wrapper.findComponent({ name: 'documents-db-transformer' })
    expect(dbTransformerWrapper.exists()).toBe(true)

    const numerotationDbAvertissementWrapper = wrapper.findComponent({ name: 'numerotations-db-avertissement' })
    expect(numerotationDbAvertissementWrapper.exists()).toBe(true)
    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(false)

    await dbTransformerWrapper.vm.$emit('documentsDbTransformerNumerotationBlOuvrirEmise')

    expect(numerotationDbAvertissementWrapper.props('numerotationsDbAvertissementVisible')).toBe(true)
  })

  it(`ouvrir l'assistant de parametrage de numerotation si aucune numerotation est configuree pour le document`, async () => {
    const pinia = createTestingPinia({
      initialState: {
        facturationNumerotations: {
          state__facturationNumerotations_liste: {
            devis: { needAssistant: true }
          },
          state__facturationNumerotations_listeCharge: true
        }
      }
    })

    const wrapper = shallowMount(FacturationDocuments, {
      global: {
        plugins: [mckitui, dayjs, axios, store, router, pinia],
      },
      props: {
        facturationDocumentsType: 'devis'
      }
    })

    expect(wrapper).toBeTruthy()

    await flushPromises()

    const assistantParametrageNumWrapper =  wrapper.findComponent({ name: 'numerotations-db-assistant-parametrage' })
    expect(assistantParametrageNumWrapper.exists()).toBe(true)
    expect(assistantParametrageNumWrapper.props('numerotationsDbAssistantParametrageVisible')).toBe(true)
    expect(assistantParametrageNumWrapper.props('numerotationsDbAssistantParametrageType')).toEqual('devis')
  })

  it('ouvrir la boite de dialogue pour le parametrage de format de numero pour un type donne', async () => {
    expect(wrapper).toBeTruthy()

    const dbAvertissementWrapper = wrapper.findComponent({ name: 'numerotations-db-avertissement' })
    expect(dbAvertissementWrapper.exists()).toBe(true)

    const dbAssistantParametrageWrapper = wrapper.findComponent({ name: 'numerotations-db-assistant-parametrage' })
    expect(dbAssistantParametrageWrapper.exists()).toBe(true)
    expect(dbAssistantParametrageWrapper.props('numerotationsDbAssistantParametrageVisible')).toBe(false)
    expect(dbAssistantParametrageWrapper.props('numerotationsDbAssistantParametrageEtape')).toEqual(1)
    
    await dbAvertissementWrapper.vm.$emit('numerotationsDbAvertissementCreerEmise')
    
    expect(dbAssistantParametrageWrapper.props('numerotationsDbAssistantParametrageVisible')).toBe(true)
    expect(dbAssistantParametrageWrapper.props('numerotationsDbAssistantParametrageEtape')).toEqual(3)
  })

  it('fermer le menu flottant quand on ouvre une boite de dialogue (ex: valider de document)', async () => {
    expect(wrapper).toBeTruthy()

    const storeFD = useFacturationDocumentsStore()
    storeFD.$patch(state => {
      state.state__facturationDocuments_liste = {
        items: [
          { uuid: '001', type: 'devis'}
        ]
      }
      state.state__facturationDocuments_documentSelections = ['001']
      state.state__facturationDocuments_actionbarConfigurations = {
        types: { devis: 1 }
      }
    })

    await wrapper.vm.$nextTick()

    const dbValiderWrapper = wrapper.findComponent({ name: 'documents-db-valider' })
    const menuFlottantWrapper = wrapper.findComponent({ name: 'documents-tableau-menu-flottant' })

    expect(dbValiderWrapper.exists()).toBe(true)
    expect(dbValiderWrapper.props('documentsDbValiderVisible')).toBe(false)

    expect(menuFlottantWrapper.exists()).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(true)

    await menuFlottantWrapper.vm.$emit('documentsTableauMenuFlottantValiderEmise')

    expect(dbValiderWrapper.props('documentsDbValiderVisible')).toBe(true)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(false)

    await dbValiderWrapper.vm.$emit('documentsDbValiderFermerEmise', false)

    expect(dbValiderWrapper.props('documentsDbValiderVisible')).toBe(false)
    expect(menuFlottantWrapper.props('documentsTableauMenuFlottantVisible')).toBe(true)
  })

  it('devrait trier correctement chaque colonne et appeler lAPI pour chaque tri', async () => {
    expect(wrapper).toBeTruthy()

    const colonnes = ['date', 'type', 'num', 'ref', 'partenaireLibelle']
    const directions = ['ASC', 'DESC']
    const storeFD = useFacturationDocumentsStore()

    const recupererDocumentsSpy = vi.spyOn(storeFD, 'action__facturationDocuments_recupererListe')

    const tableauWrapper = wrapper.findComponent({ name: 'documents-tableau' })
    expect(tableauWrapper.exists()).toBe(true)

    for (const colonne of colonnes) {
      for (const direction of directions) {  
        const tri = `${colonne}_${direction}`

        expect(recupererDocumentsSpy).not.toHaveBeenCalledWith()

        await tableauWrapper.vm.$emit('documentsTableauTrierEmise', tri)
        
        const emise = tableauWrapper.emitted('documentsTableauTrierEmise')
        
        expect(recupererDocumentsSpy).toHaveBeenCalledTimes(emise.length)
        expect(emise.slice(-1)[0][0]).toBe(tri)
      }
    }

    expect(tableauWrapper.emitted('documentsTableauTrierEmise').length).toBe(colonnes.length * directions.length)
  })
})
